using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MLib3.MVVM.SourceGenerators;

[Generator]
public class ViewModelPropertyExposerIncrementalSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(postInitializationContext =>
        {
            postInitializationContext.AddSource("ExposeModelPropertyAttribute.g.cs", SourceText.From(
@"// <auto-generated/>
namespace MLib3.MVVM;

[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
sealed class ExposeModelPropertyAttribute : Attribute
{
    public ExposeModelPropertyAttribute(string modelPropertyName)
    {
        ModelPropertyName = modelPropertyName;
    }

    public string ModelPropertyName { get; set; }
}", Encoding.UTF8));
        });
        
        var viewModelProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => IsPotentialViewModelBaseImplementor(s),
                (ctx, _) => GetViewModelBaseImplementors(ctx))
            .Where(t => t != null)
            .Collect();

        context.RegisterSourceOutput(context.CompilationProvider.Combine(viewModelProvider),
            (ctx, t) => GenerateViewLocator(ctx, t.Left, t.Right));
    }

    private bool IsPotentialViewModelBaseImplementor(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not ClassDeclarationSyntax classDeclaration)
            return false;

        // Check if the class name ends with VM
        if (!classDeclaration.Identifier.Text.EndsWith("VM"))
            return false;

        // Check if class is possibly decorated with ExposeModelPropertyAttribute
        if (classDeclaration.AttributeLists.Count <= 0)
            return false;

        // Check if class is partial
        if (classDeclaration.Modifiers.All(x => x.ValueText != "partial"))
            return false;
        
        // Check if class could possibly derive from ViewModel<T>
        if (classDeclaration.BaseList is null)
            return false;
        
        return true;
    }

    private static ViewModelBaseType? GetViewModelBaseImplementors(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (classSymbol == null)
            return null;
        
        // Check if the class is decorated with ExposeModelPropertyAttribute
        var hasExposeModelPropertyAttribute = classDeclaration.AttributeLists
            .SelectMany(x => x.Attributes)
            .Any(x => x.Name.ToString() == "ExposeModelProperty");
        
        if (!hasExposeModelPropertyAttribute) 
            return null;
        
        // Get all the ExposeModelPropertyAttribute attributes and their arguments
        // The Argument can be in the form of a string or a nameof expression (e.g. nameof(Model.Name))
        var exposedProperties = classSymbol.GetAttributes()
            .Where(x => x.AttributeClass?.Name == "ExposeModelPropertyAttribute")
            .Select(x => x.ConstructorArguments[0].Value?.ToString() ?? x.NamedArguments[0].Value.Value?.ToString())
            .Where(x => x != null)
            .Select(x => x!)
            .ToImmutableArray();
        
        // Check if the class derives from ViewModel<T>
        var implementsViewModelBase = false;
        var baseType = classSymbol.BaseType;
        while (baseType != null)
        {
            if (baseType.ToDisplayString().StartsWith("MLib3.MVVM.ViewModel<"))
            {
                implementsViewModelBase = true;
                break;
            }

            baseType = baseType.BaseType;
        }

        if (!implementsViewModelBase) 
            return null;

        // Get the Namespace of the class
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        // Get the Name of the class
        var className = classSymbol.Name;

        return new ViewModelBaseType(namespaceName, className, exposedProperties);
    }

    private void GenerateViewLocator(SourceProductionContext context, Compilation compilation, ImmutableArray<ViewModelBaseType?> viewModelBaseTypes)
    {
        var partialViewModel = new StringBuilder();

        foreach (var viewModel in viewModelBaseTypes)
        {
            if (viewModel == null)
                continue;
            partialViewModel.AppendLine($@"// <auto-generated/>
namespace {viewModel.Value.Namespace};

public partial class {viewModel.Value.Name}
{{");
            foreach (var exposedProperty in viewModel.Value.ExposedProperties)
            {
                partialViewModel.AppendLine(
                    $@"    public string {exposedProperty} 
    {{
        get => Model.{exposedProperty};
        set => SetProperty(Model.{exposedProperty}, value, Model, (model, value) => model.{exposedProperty} = value);
    }}");
            }

            partialViewModel.AppendLine("}");
            context.AddSource($"{viewModel.Value.Name}.g.cs", SourceText.From(partialViewModel.ToString(), Encoding.UTF8));
        }
    }
}