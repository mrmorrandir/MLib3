using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MLib3.MVVM.SourceGenerators;

[Generator]
public class ModelPropertyExposer : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(postInitializationContext =>
        {
            postInitializationContext.AddSource("ExposeModelPropertyAttribute.g.cs", SourceText.From(
                @"// <auto-generated/>
using System;

[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
public sealed class ExposeModelPropertyAttribute : Attribute
{
    public ExposeModelPropertyAttribute(string modelPropertyName)
    {
        ModelPropertyName = modelPropertyName;
    }

    public string ModelPropertyName { get; set; }
}", Encoding.UTF8));
        });

        var viewModelProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => IsPotentialViewModelBaseImplementor(s),
                (ctx, _) => GetViewModelBaseImplementors(ctx))
            .Where(t => t != null)
            .Collect();

        context.RegisterSourceOutput(context.CompilationProvider.Combine(viewModelProvider),
            (ctx, t) => GenerateExposedProperties(ctx, t.Left, t.Right));
    }

    private bool IsPotentialViewModelBaseImplementor(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not ClassDeclarationSyntax classDeclaration)
            return false;

        // Check if the class name ends with VM
        if (!classDeclaration.Identifier.Text.EndsWith("VM"))
            return false;

        // Check if class is possibly decorated with ExposeModelPropertyAttribute
        if (classDeclaration.AttributeLists.Count <= 0)
            return false;

        // Check if class is partial
        if (classDeclaration.Modifiers.All(x => x.ValueText != "partial"))
            return false;

        // Check if class could possibly derive from ViewModel<T>
        if (classDeclaration.BaseList is null)
            return false;

        return true;
    }

    private static ViewModelBaseType? GetViewModelBaseImplementors(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (classSymbol == null)
            return null;

        // Check if the class is decorated with ExposeModelPropertyAttribute
        var hasExposeModelPropertyAttribute = classDeclaration.AttributeLists
            .SelectMany(x => x.Attributes)
            .Any(x => x.Name.ToString() == "ExposeModelProperty");

        if (!hasExposeModelPropertyAttribute)
            return null;

        // Get all the ExposeModelPropertyAttribute attributes and their arguments
        // The Argument can be in the form of a string or a nameof expression (e.g. nameof(Model.Name))
        var exposedProperties = classSymbol.GetAttributes()
            .Where(x => x.AttributeClass?.Name == "ExposeModelPropertyAttribute")
            .Select(x => x.ConstructorArguments[0].Value?.ToString() ?? x.NamedArguments[0].Value.Value?.ToString())
            .Where(x => x != null)
            .Select(x => x!)
            .ToImmutableArray();

        // Check if the class derives from ViewModel<T>
        var implementsViewModelBase = false;
        var baseType = classSymbol.BaseType;
        while (baseType != null)
        {
            if (baseType.ToDisplayString().StartsWith("MLib3.MVVM.ViewModel<"))
            {
                implementsViewModelBase = true;
                break;
            }

            baseType = baseType.BaseType;
        }

        if (!implementsViewModelBase)
            return null;

        // Get the Namespace of the class
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        // Get the Name of the class
        var className = classSymbol.Name;

        return new ViewModelBaseType(namespaceName, className, exposedProperties);
    }

    private void GenerateExposedProperties(SourceProductionContext context, Compilation compilation, ImmutableArray<ViewModelBaseType?> viewModelBaseTypes)
    {
        var descriptor = new DiagnosticDescriptor(
            id: "VMGEN001",
            title: "ViewModel Code Generation",
            messageFormat: "Processing ViewModel: {0}",
            category: "SourceGenerator",
            defaultSeverity: DiagnosticSeverity.Info,
            isEnabledByDefault: true);
    
        if (viewModelBaseTypes.IsDefaultOrEmpty)
        {
            context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, "No ViewModels found"));
            return;
        }
    
        foreach (var viewModelClass in viewModelBaseTypes)
        {
            if (viewModelClass == null)
            {
                continue;
            }
    
            context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, $"{viewModelClass.Value.Namespace}.{viewModelClass.Value.Name} with {viewModelClass.Value.ExposedProperties.Length} properties"));
    
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine($"// Exposed properties for {viewModelClass.Value.Name}");
            sb.AppendLine();
            sb.AppendLine($"namespace {viewModelClass.Value.Namespace}");
            sb.AppendLine("{");
            sb.AppendLine($"    public partial class {viewModelClass.Value.Name}");
            sb.AppendLine("    {");
    
            foreach (var exposedProperty in viewModelClass.Value.ExposedProperties)
            {
                sb.AppendLine($"        public string {exposedProperty}");
                sb.AppendLine("        {");
                sb.AppendLine($"            get => Model.{exposedProperty};");
                sb.AppendLine($"            set => SetProperty(Model.{exposedProperty}, value, Model, (model, value) => model.{exposedProperty} = value);");
                sb.AppendLine("        }");
            }
    
            sb.AppendLine("    }");
            sb.AppendLine("}");
    
            var hintName = $"{viewModelClass.Value.Namespace}.{viewModelClass.Value.Name}.g.cs";
            context.AddSource(hintName, SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }
}